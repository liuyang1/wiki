Riak and Erlang/OTP

Riak 是一个分布式的,容错的开源数据库,用来展示利用Erlang/OTP如何构建一个大规模尺度上的系统.得益于Erlang对于大规模尺度分布式系统的支持,Riak提供了一些常规数据库不支持的特性.像高可用性,在容量和吞吐量上同时支持线性尺度扩展.

Erlang/OTP提供构建类似于Riak的理想的平台,因为它提供了直接提供(开箱可用的)节点间通信,消息队列,失败检测,CS抽象特性.而且在Erlang中最为常用的模式,已经作为库模块实现了,一般是OTP的behavior.它们包含用于并发的通用的代码框架和错误处理,简化的并发编程保护开发者避免很多一般性的错误.Behavior被supvisor监控,而behavior则组合为一个监督树,一个监督树是打包在一起的一个应用,作为Erlang程序的一个build的block.

一个完整的Erlang系统,像Riak,是有一系列的彼此交互的松散连接的应用组成的.一些由开发者完成,一些则是标准的OTP的一部分,另一些则是开源的组件.它们利用一个根据应用的列表和版本的启动脚本来顺序载入.

和系统的区分在于,应用是发布的时候开始的.在标准的Erlang发行中,启动文件将开始kernel和标准库应用.在有些安装汇总,SASL(系统架构支持库)应用也会开始.SASL包含了带有日志功能的发布和软件升级工具.Riak,也和其他应用一样,开始riak应用,以及它的运行时依赖,包括Kernel,stdlib,SASL.一个完整的,随时可运行的Riak,实际上嵌入这些Erlang/OTP发布的标准元素.当在命令行敲击`riak start`的时候,这些其实是一起启动的.Riak包含了很多复杂应用,因此本章不会成为完整的帮助手册,这些可以通过阅读OTP的介绍,以及Riak源码中的例子.

## 15.1 简介Erlang
Erlang是一门并发函数式编程语言,可以编译为字节码运行在虚拟机上.程序中不同的函数互相调用,许多有着副作用:进程间消息传递,IO,数据库操作.Erlang中的变量是唯一赋值的,也就是赋值之后,不可以再次改变或者更新.语言中采用很多模式匹配的写法,例如:

"""
-module(factorial).
-export([fac/1]).
fac(0) -> 1;
fac(N) when N > 0 ->
    Prev = fac(N - 1),
    N * Prev.
    }}}

"""

fac的第一部分定义了输入值为0的情况,第二个定义了正整数的情况.
函数体的每个部分由一系列的表示式组成,最后一个表达式是本部分的函数返回结果.

NOTE:
clause翻译成什么比较好呢?

如果fac的参数为负数,那么则会得到一个运行时错误,因为它不能够匹配到fac函数的任意一个部分.没有处理负数这种情况,恰恰是一种防御式编程,这在Erlang中是一种鼓励的风格.

NOTE:
因为会在错误发生最早的地方就会得到一个错误.而不会将这个错误的结果,或者错误码传递给调用fac的其他部分,这些其他部分则不得不处理这部分错误,从而使得错误的代码分散在系统的每一个角落.从而如果有一个地方没有进行类似的防御都可能造成错误,程序变得极其脆弱.
同时,当最终错误导致系统崩溃的地方,则因为已经可能经历过多次的错误处理,而远离了错误发生时候的现场环境,反而导致程序在相关问题上debug的时候,更加复杂.

在模块内部,函数调用和一般方式比较像.在模块外部的时候,函数名必须以模块名为前缀,例如`factorial:fac(3)`.同时,可以定义函数有着相同的名字,但是有不同的变量个数,这在Erlang中称之为arity.因此在模块的开始处,声明函数的时候需要显式指明fac的变量个数为1.

Erlang支持元组tuple(也称之为乘法结构)和列表list.

NOTE:
第一次听说(product types)这种说法.是因为元组是多个数据结合的乘集的缘故吗?还是我完全理解错误了?

元组使用大括号包围起来.在元组中,我们可以通过位置获取元素.Record是另外一种数据类型,它们允许存储固定个数的元素,然后可以通过名字来访问处理,例如可以定义Record使用`-record(state, {id, msg_list=[]}).`,为了创建一个实例,我们可以使用表达式`Var = #state{id=1}`,然后可以通过`#Var#state.id`可以检验它们的内容,使用方括号表示的列表,对于`[X|Xs]`则匹配一个非空列表,列表的首部为X,尾部为Xs. 注意,以小写字母开始的是符号(atom),例如:`{ok, 37}`就是atom的例子. atom这种使用方式,经常用来区分函数的不同返回值,例如相对于ok的`{error, "Error String"}`.

Erlang系统中不同的进程分别并发地在不同的内存运行,相互之间通信通过消息传递进行.进程可以用于大量的引用,例如到数据库的网关(负责处理协议栈).负责管理其他进程的跟踪日志信息.尽管这些进程负责不同的请求,但是如何处理请求是相似.

进程因为只在虚拟机中存在,因此一个单独的虚拟机可以运行百万个进程.例如,每个到数据库的请求,读取,写入,删除都是一个独立的进程,和操作系统级别的线程实现无关.

进程通过进程标识符PID来识别,但是可以注册在一个名字上.这一般用于长期存在的"静态"进程.其他进程不需要知道PID,而可以直接发送消息给命名进程.通过`spawn(Module, Function, Arguments)`这个内置函数(BIF)来创建进程.内置函数(BIF)是虚拟机中内置的,用于完成纯Erlang语言无法完成,或者完成效率较低的功能.`spawn/3`返回新创建的进程的PID.作为副作用,创建一个新的进程,执行参数中描述的函数.

消息`Msg`可以传递给进程`Pid`,通过`Pid ! Msg`.进程可以通过`self`函数得到自身的Pid,也可以通过消息传递函数将自身的进程号传递给其他进程.假设进程期望收到`{ok, N}`或者`{error, Reason}`形式的消息,那么可以使用`receive`语句:

    receive
        {ok, N} -> N + 1;
        {error, _} -> 0;
    end

上述的形式,就是利用了模式匹配部分.当变量中不需要的部分,可以使用下划线,直接对齐进行忽略.

进程之间的消息传递是异步的,进程收到的消息是在进程的收件箱中按照收到顺序排列的.如果不符合上述形式的消息,则会保留在收件箱中.如果收件箱中没有匹配的消息,那么receive将会一直等待.


