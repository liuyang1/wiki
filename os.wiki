= os =
%toc
操作系统
----

== 信号量 ==
OS中使用P V信号来分析互斥区.passeren,vrijgeven,mutex.

使用信号量及互斥区的概念,有效的忽略了各个单元之间速度的差异.
仅仅通过临界区这个"点"的操作,就可以完成各个单元之间的同步问题.

测试置位(test-and-set)的思想,就是来源与这里,并且利用硬件,实现为原子操作.

== 死锁问题 ==
死锁是同时存在多个互斥的资源场景下,各个单元之间,不能够公平且有效的分享资源的问题.

这个问题的极限情况,就是多个单元陷于一个局面(谁都无法获得足够的资源完成任务).

死锁产生的条件:
# 互斥,mutual exclusion 临界资源.
# 占有并等待(hold and wait). 已经获得部分资源的进程,还可以申请其他新资源.
# 不可剥夺(no preemption).  已经分配的资源,如果其宿主没有释放,则不允许剥夺
# 循环等待  多个进程之间形成链式依赖,等待对方资源.

预防:
显然避免上述情况,就可以预防.
# 破坏占有等待条件.
进程必须一次请求所需要的所有资源,如果不成功,等待.总之,就是全部资源的获取和释放都是原子性的.

这个很难满足,因为进程需要的资源很可能是变化且动态的.

# 破坏不可剥夺条件.
一个占有资源进程,再次申请资源的时候,必须先释放已有资源.之后再次重新申请.

这个的实现,相对容易.但是却增加了复杂度.

# 破坏循环等待条件.
将资源标号.必须按照特定顺序获取资源.

这个方法,还可以.

避免:

死锁预防,是破坏产生条件,但是系统的并发并行特性也受到影响.

上述的条件中,前3个是基本条件.最后一个为死锁的状态.如果避免出现最后一种情况,则可以在不修改进程获取资源方式的情况下,避免死锁现象的发生.

# 如果进程当前请求的资源导致死锁,则拒绝该进程.
# 如果资源的分配,导致下一步死锁,则拒绝此次分配.

TODO:

这样子有问题啊.系统如何知道这一点呢?

=== 公平性 ===
为了公平性,则需要引进随机性.

当进程获取资源失败,则等待一个随机时间,然后再次获取.

以太网中的CSMA/CD技术,也应用到随机性.和这里的资源获取,以及保持公平性方面是一致的.


=== 面包店Lamport算法 ===
ref:http://blog.csdn.net/lmh12506/article/details/6663410


